<!DOCTYPE html>
<html>
<head></head>

<body style="background-color: black; color: white">
<canvas id="canvas"></canvas>
<div id="number">0</div>
</body>

<script>

// NOTE: All dimensions are in world units where 1wu = 1 cell dim
// unless specified otherwise (e.g., DimPx = dim in px)
// Coordinates are top-down, left-right. 0 is the edge, not the center
// All time is in ms
let globalState = {
    lastTimestamp: 0,
    worldDim: {x: 10, y: 10},
    cursor: {x: 0, y: 0, leftButtonDown: false},
    entities: {
        storage: [],
    },
    referenceCycleDuration: 1000,
    cellDimPx: 50,
    gridCellBorderWidthPx: 1,
}

function posIsInBounds(posX, posY) {
    const result = posX >= 0 && posX < globalState.worldDim.x && posY >= 0 && posY < globalState.worldDim.y
    return result
}

function getEntityHandleAtPos(posX, posY) {
    const handle = {valid: false, index: 0}
    if (posIsInBounds(posX, posY)) {
        handle.valid = true
        handle.index = posY * globalState.worldDim.x + posX
    }
    return handle
}

function getEntityPos(handle) {
    const pos = {valid: false, x: 0, y: 0};
    if (handle.valid) {
        pos.valid = true
        pos.x = handle.index % globalState.worldDim.x
        pos.y = Math.floor(handle.index / globalState.worldDim.x)
    }
    return pos
}

function getEntityUnsafe(handle) {
    entity = globalState.entities.storage[handle.index]
    return entity
}

function startWorkingConditionally(handle, condition, efficiency) {
    if (handle.valid) {
        const entity = getEntityUnsafe(handle)
        entity.currentRate = 0
        const pos = getEntityPos(handle)
        const entityOnLeftHandle = getEntityHandleAtPos(pos.x - 1, pos.y)
        if (entityOnLeftHandle.valid) {
            const entityOnLeft = getEntityUnsafe(entityOnLeftHandle)        
            entity.currentRate = entityOnLeft.currentRate * efficiency
        }
    }    
}

function beginEntityIteration() {
    const iterator = {pos: {x: -1, y: 0}, handle: null, entity: null, done: false}
    return iterator
}

function nextEntity(iterator) {
    if (!iterator.done) {
        iterator.pos.x += 1
        if (iterator.pos.x >= globalState.worldDim.x) {
            iterator.pos.x = 0
            iterator.pos.y += 1
            if (iterator.pos.y >= globalState.worldDim.y) {
                iterator.done = true
                iterator.handle = null
                iterator.entity = null
            }
        }
        if (!iterator.done) {
            iterator.handle = getEntityHandleAtPos(iterator.pos.x, iterator.pos.y)
            iterator.entity = getEntityUnsafe(iterator.handle)
        }
    }
    return iterator
}

function nextNonNullEntity(iterator) {
    do {
        nextEntity(iterator)
    } while (!iterator.done && iterator.entity.kind === "none")
    return iterator
}

function gameUpdateAndRender(timestamp) {
    const deltaTime = timestamp - globalState.lastTimestamp
    globalState.lastTimestamp = timestamp

    // NOTE: Update

    // NOTE: Entities
    for (const entityIterator = nextNonNullEntity(beginEntityIteration()); !entityIterator.done; nextNonNullEntity(entityIterator)) {
        const entity = entityIterator.entity
        const pos = entityIterator.pos
        switch (entity.kind) {
            case "producer": {
                startWorkingConditionally(entityIterator.handle, "motor", 0.8)
            } break
            case "motor": {
                startWorkingConditionally(entityIterator.handle, "generator", 0.5)
            } break
            case "generator": {
                const isCursorOver = Math.floor(globalState.cursor.x) === pos.x && Math.floor(globalState.cursor.y) === pos.y
                entity.currentRate = isCursorOver && globalState.cursor.leftButtonDown ? 1 : 0
            } break
            default: console.error(`unknown entity type: '${entity.kind}'`)
        }

        while (entity.cycleProgress >= 1) {
            entity.cycleProgress -= 1
        }
        entity.cycleProgress += deltaTime / globalState.referenceCycleDuration * entity.currentRate
    }

    // NOTE: Render

    const canvas = document.getElementById("canvas")    
    
    const worldDimXPx = globalState.worldDim.x * globalState.cellDimPx
    const worldDimYPx = globalState.worldDim.y * globalState.cellDimPx
    canvas.setAttribute("width", worldDimXPx)
    canvas.setAttribute("height", worldDimYPx)
    
    const ctx = canvas.getContext("2d")

    // NOTE: Clear
    ctx.fillStyle = "black"
    ctx.fillRect(0, 0, worldDimXPx, worldDimYPx)
    
    // NOTE: Grid
    {
        ctx.fillStyle = "gray"
        for (let currentXPx = 0; currentXPx <= worldDimXPx; currentXPx += globalState.cellDimPx) {
            ctx.fillRect(currentXPx - globalState.gridCellBorderWidthPx, 0, globalState.gridCellBorderWidthPx * 2, worldDimYPx)
        }
        for (let currentYPx = 0; currentYPx <= worldDimYPx; currentYPx += globalState.cellDimPx) {
            ctx.fillRect(0, currentYPx - globalState.gridCellBorderWidthPx, worldDimXPx, globalState.gridCellBorderWidthPx * 2)
        }
    }

    // NOTE: Entities
    for (const entityIterator = nextNonNullEntity(beginEntityIteration()); !entityIterator.done; nextNonNullEntity(entityIterator)) {
        const entity = entityIterator.entity
        const pos = entityIterator.pos

        let cellBg = "magenta"
        let letter = "X"
        switch (entity.kind) {
            case "producer": {
                cellBg = "darkred"
                letter = "P"
            } break
            case "motor": {
                cellBg = "green"
                letter = "M"
            } break
            case "generator": {
                cellBg = "darkblue"
                letter = "G"
            } break
            default: console.error(`unknown entity type: '${entity.kind}'`)
        }

        const cellLeftPx = pos.x * globalState.cellDimPx
        const cellTopPx = pos.y * globalState.cellDimPx

        ctx.fillStyle = cellBg
        ctx.fillRect(cellLeftPx, cellTopPx, globalState.cellDimPx, globalState.cellDimPx)

        ctx.fillStyle = "white"
        ctx.textBaseline = "bottom"
        ctx.fillText(`${Math.floor(entity.cycleProgress * 100)}`, cellLeftPx, cellTopPx + globalState.cellDimPx)

        ctx.fillStyle = "black"
        ctx.textBaseline = "top"
        ctx.fillText(letter, cellLeftPx, cellTopPx)

        const orbitingSquareDimPx = 3
        const orbitingSquareHalfDimPx = orbitingSquareDimPx / 2
        const orbitingSquarePaddingPx = 1
        const cellHalfDim = globalState.cellDimPx / 2
        const orbitRadiusPx = cellHalfDim - globalState.gridCellBorderWidthPx - orbitingSquarePaddingPx - orbitingSquareDimPx

        const cellCenterXPx = cellLeftPx + cellHalfDim
        const cellCenterYPx = cellTopPx + cellHalfDim
        const proportionOfTimeWaited = entity.cycleProgress
        const currentAngleFromTop = proportionOfTimeWaited // NOTE: in turns, clockwise
        const orbitingSquareOffsetXPx = Math.sin(currentAngleFromTop * 2 * Math.PI) * orbitRadiusPx
        const orbitingSquareOffsetYPx = Math.cos(currentAngleFromTop * 2 * Math.PI) * orbitRadiusPx
        const orbitingSquareCenterXPx = cellCenterXPx + orbitingSquareOffsetXPx
        const orbitingSquareCenterYPx = cellCenterYPx - orbitingSquareOffsetYPx

        ctx.fillStyle = "lightgray"
        ctx.fillRect(orbitingSquareCenterXPx - orbitingSquareHalfDimPx, orbitingSquareCenterYPx - orbitingSquareHalfDimPx, orbitingSquareDimPx, orbitingSquareDimPx)
    }

    // for (let entityIndex = 1; entityIndex < globalState.entities.length; entityIndex++) {
    //     const entity = globalState.entities[entityIndex]        
    // }

    requestAnimationFrame(gameUpdateAndRender)
}

function main() {

    // NOTE: Input
    document.addEventListener("mousemove", (event) => {
        const canvasRect = canvas.getBoundingClientRect()
        const cursorXPx = event.clientX - canvasRect.left
        const cursorYPx = event.clientY - canvasRect.top
        globalState.cursor.x = cursorXPx / globalState.cellDimPx
        globalState.cursor.y = cursorYPx / globalState.cellDimPx
    })

    document.addEventListener("mousedown", (event) => {
        if (event.button === 0) {
            globalState.cursor.leftButtonDown = true
        }
    })

    document.addEventListener("mouseup", (event) => {
        if (event.button === 0) {
            globalState.cursor.leftButtonDown = false
        }
    })

    // NOTE: Init
    {
        const entityCount = globalState.worldDim.x * globalState.worldDim.y
        for (let entityIndex = 0; entityIndex < entityCount; entityIndex++) {
            globalState.entities.storage.push({
                kind: "none",
                currentRate: 0,
                cycleProgress: 0,
            })
        }

        // NOTE: Temp setup some test entities
        {
            const handle = getEntityHandleAtPos(0, 5)
            if (handle.valid) {
                const entity = getEntityUnsafe(handle)
                entity.kind = "generator"
            }
        }
        {
            const handle = getEntityHandleAtPos(1, 5)
            if (handle.valid) {
                const entity = getEntityUnsafe(handle)
                entity.kind = "motor"
            }
        }
        {
            const handle = getEntityHandleAtPos(2, 5)
            if (handle.valid) {
                const entity = getEntityUnsafe(handle)
                entity.kind = "producer"
            }
        }
    }

    // NOTE: Mainloop
    requestAnimationFrame((timestamp) => {
        globalState.lastTimestamp = timestamp
        requestAnimationFrame(gameUpdateAndRender)
    })
}

main()

</script>

</html>