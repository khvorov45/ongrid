<!DOCTYPE html>
<html>
<head></head>

<body style="background-color: black; color: white">
<canvas id="canvas"></canvas>
<div id="number">0</div>
</body>

<script>

// NOTE: All dimensions are in world units where 1wu = 1 cell dim
// unless specified otherwise (e.g., DimPx = dim in px)
// Coordinates are top-down, left-right. 0 is the edge, not the center
// All time is in ms
let globalState = {
    lastTimestamp: 0,
    worldDim: {x: 10, y: 10},
    cursor: {x: 0, y: 0, leftButtonDown: false},
    entities: [
        {kind: "producer", pos: {x: 3, y: 4}, cycleProgress: 0, currentRate: 0},
        {kind: "motor", pos: {x: 2, y: 4}, cycleProgress: 0, currentRate: 0},
        {kind: "generator", pos: {x: 1, y: 4}, cycleProgress: 0, currentRate: 0},
    ],
    referenceCycleDuration: 1000,
    cellDimPx: 50,
    gridCellBorderWidthPx: 1,
}

function gameUpdateAndRender(timestamp) {
    const deltaTime = timestamp - globalState.lastTimestamp
    globalState.lastTimestamp = timestamp

    // NOTE: Update

    // NOTE: Entities
    for (let entityIndex = 0; entityIndex < globalState.entities.length; entityIndex++) {
        const entity = globalState.entities[entityIndex]

        switch (entity.kind) {
            case "producer": {
                const motor = globalState.entities.find(e => e.kind === "motor" && e.pos.x === entity.pos.x - 1 && e.pos.y === entity.pos.y)
                const efficiency = 0.5
                entity.currentRate = motor.currentRate * efficiency
            } break
            case "motor": {
                const generator = globalState.entities.find(e => e.kind === "generator" && e.pos.x === entity.pos.x - 1 && e.pos.y === entity.pos.y)
                const efficiency = 0.8
                entity.currentRate = generator.currentRate * efficiency
            } break
            case "generator": {
                const isCursorOver = Math.floor(globalState.cursor.x) === entity.pos.x && Math.floor(globalState.cursor.y) === entity.pos.y
                entity.currentRate = isCursorOver && globalState.cursor.leftButtonDown ? 1 : 0
            } break
            default: console.error(`unknown entity type: '${entity.kind}'`)
        }

        while (entity.cycleProgress >= 1) {
            entity.cycleProgress -= 1
        }
        entity.cycleProgress += deltaTime / globalState.referenceCycleDuration * entity.currentRate
    }

    // NOTE: Render

    const canvas = document.getElementById("canvas")    
    
    const worldDimXPx = globalState.worldDim.x * globalState.cellDimPx
    const worldDimYPx = globalState.worldDim.y * globalState.cellDimPx
    canvas.setAttribute("width", worldDimXPx)
    canvas.setAttribute("height", worldDimYPx)
    
    const ctx = canvas.getContext("2d")

    // NOTE: Clear
    ctx.fillStyle = "black"
    ctx.fillRect(0, 0, worldDimXPx, worldDimYPx)
    
    // NOTE: Grid
    {
        ctx.fillStyle = "gray"
        for (let currentXPx = 0; currentXPx <= worldDimXPx; currentXPx += globalState.cellDimPx) {
            ctx.fillRect(currentXPx - globalState.gridCellBorderWidthPx, 0, globalState.gridCellBorderWidthPx * 2, worldDimYPx)
        }
        for (let currentYPx = 0; currentYPx <= worldDimYPx; currentYPx += globalState.cellDimPx) {
            ctx.fillRect(0, currentYPx - globalState.gridCellBorderWidthPx, worldDimXPx, globalState.gridCellBorderWidthPx * 2)
        }
    }

    // NOTE: Entities
    for (let entityIndex = 0; entityIndex < globalState.entities.length; entityIndex++) {
        const entity = globalState.entities[entityIndex]

        let cellBg = "magenta"
        let letter = "X"
        switch (entity.kind) {
            case "producer": {
                cellBg = "darkred"
                letter = "P"
            } break
            case "motor": {
                cellBg = "green"
                letter = "M"
            } break
            case "generator": {
                cellBg = "darkblue"
                letter = "G"
            } break
            default: console.error(`unknown entity type: '${entity.kind}'`)
        }

        const cellLeftPx = entity.pos.x * globalState.cellDimPx
        const cellTopPx = entity.pos.y * globalState.cellDimPx

        ctx.fillStyle = cellBg
        ctx.fillRect(cellLeftPx, cellTopPx, globalState.cellDimPx, globalState.cellDimPx)

        ctx.fillStyle = "white"
        ctx.textBaseline = "bottom"
        ctx.fillText(`${Math.floor(entity.cycleProgress * 100)}`, cellLeftPx, cellTopPx + globalState.cellDimPx)

        ctx.fillStyle = "black"
        ctx.textBaseline = "top"
        ctx.fillText(letter, cellLeftPx, cellTopPx)

        const orbitingSquareDimPx = 3
        const orbitingSquareHalfDimPx = orbitingSquareDimPx / 2
        const orbitingSquarePaddingPx = 1
        const cellHalfDim = globalState.cellDimPx / 2
        const orbitRadiusPx = cellHalfDim - globalState.gridCellBorderWidthPx - orbitingSquarePaddingPx - orbitingSquareDimPx

        const cellCenterXPx = cellLeftPx + cellHalfDim
        const cellCenterYPx = cellTopPx + cellHalfDim
        const proportionOfTimeWaited = entity.cycleProgress
        const currentAngleFromTop = proportionOfTimeWaited // NOTE: in turns, clockwise
        const orbitingSquareOffsetXPx = Math.sin(currentAngleFromTop * 2 * Math.PI) * orbitRadiusPx
        const orbitingSquareOffsetYPx = Math.cos(currentAngleFromTop * 2 * Math.PI) * orbitRadiusPx
        const orbitingSquareCenterXPx = cellCenterXPx + orbitingSquareOffsetXPx
        const orbitingSquareCenterYPx = cellCenterYPx - orbitingSquareOffsetYPx

        ctx.fillStyle = "lightgray"
        ctx.fillRect(orbitingSquareCenterXPx - orbitingSquareHalfDimPx, orbitingSquareCenterYPx - orbitingSquareHalfDimPx, orbitingSquareDimPx, orbitingSquareDimPx)
    }

    requestAnimationFrame(gameUpdateAndRender)
}

function main() {
    // NOTE: Can't read input in real time lol
    document.addEventListener("mousemove", (event) => {
        const canvasRect = canvas.getBoundingClientRect()
        const cursorXPx = event.clientX - canvasRect.left
        const cursorYPx = event.clientY - canvasRect.top
        globalState.cursor.x = cursorXPx / globalState.cellDimPx
        globalState.cursor.y = cursorYPx / globalState.cellDimPx
    })

    document.addEventListener("mousedown", (event) => {
        if (event.button === 0) {
            globalState.cursor.leftButtonDown = true
        }
    })

    document.addEventListener("mouseup", (event) => {
        if (event.button === 0) {
            globalState.cursor.leftButtonDown = false
        }
    })

    requestAnimationFrame((timestamp) => {
        globalState.lastTimestamp = timestamp
        requestAnimationFrame(gameUpdateAndRender)
    })
}

main()

</script>

</html>